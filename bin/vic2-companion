#!/usr/bin/env perl6

use lib 'lib';
use PDS;
use PDS::Victoria2;

sub path-components(IO:D \path --> List:D)
{
    # this appears to race during multiprocessing and leads to all kinds of headaches
    # path.SPEC.splitdir(path)
    path.path.split(path.SPEC.dir-sep).List
}

#| Example: C<path-matches("path/to/a/b/c.txt".IO, <a b c.txt>)>
sub path-matches(IO:D \path, Positional \components --> Bool:D)
{
    my \path-comps = path-components(path);

    components.elems <= path-comps.elems &&
    # from most to least specific component part
    [&&] path-comps.reverse Zeq components.reverse
}

sub is-whitelisted(IO:D \candidate, Positional \whitelist --> Bool:D)
{
    so whitelist.any ~~ { path-matches(candidate, path-components($^whitelisted)) }
}

constant victoria2-grammars = (
    # not ready yet
    PDS::Victoria2::Events,
);

constant victoria2-fallback = PDS::Unstructured;

# MAIN parameter constraints

subset Path             of Str;
subset Positive         of Int where 0 < *;
subset OptionalPositive of Int where Any:U|Positive|Bool;
subset OptionalPath     of Any where Any:U|Str|Bool;
enum   When              « never always auto »;

#| Perform static analysis of Victoria 2 game files.
unit sub MAIN(
    #| game or mod paths to analyse recursively (relative to <base> when specified, current working directory otherwise)
    **@paths,

    #| number of parallel jobs (default: 1.25 × number of cores, rounded)
    Positive :j(:$jobs) = round(1.25 * $*KERNEL.cpu-cores),

    #| when to colourise the output (default: ‘auto’), but note that colour output can only be performed if
    #| Terminal::ANSIColor is installed
    When :colour(:$color) = When::auto,

    #| periodically emit a heartbeat message, useful during long processings (interval in seconds, default if flag is
    #| set: 30s)
    OptionalPositive :$heartbeat is copy,

    #| whitelist file to read, containing one file (and not a directory) that is expected to fail per line (default if
    #| flag is set: ‘whitelist’)
    OptionalPath :$whitelist is copy,

    #| base path to game or mod files
    Path :$base is copy,

    #| comma-separated list of extensions for the files of interest (default: ‘txt’)
    Str :$exts = "txt",

    #| comma-separated list of kinds of remarks to display (default: none, possible kinds: ‘opinion’)
    Str :$remarks = "",
);

# process arguments

my &style-with-colours = do if (Nil !=== try require Terminal::ANSIColor)
                               && ($color eqv When::always || ($color eqv When::auto && $*OUT.t)) {
    ::("Terminal::ANSIColor::EXPORT::DEFAULT::&colored")
} else {
    sub plain(\text, $) { text }
};

$heartbeat = do given $heartbeat -> $_ --> Int {
    when * eqv True  { 30 }
    when * eqv False { Nil }
    default          { $_ andthen .Int orelse Nil }
}

$whitelist = do given $whitelist -> $_ --> Str {
    when * eqv True  { "whitelist" }
    when * eqv False { Nil }
    default          { $_ andthen .Str orelse Nil }
}
my List:D \whitelist = do with $whitelist { .IO.lines.grep(''.none)».&{.trim.IO.cleanup} } // ();

my \exts = $exts.split(",")».fc.any;
my @requests = ($base ?? @paths.map({ $base.IO.add(.IO) }) !! @paths».IO)».cleanup;

my IO:D @files = gather {
    my @pending = @requests;
    while @pending {
        with @pending.shift {
            when :d { @pending.append(.dir) }
            .take when .extension(:parts(^Inf)).fc ~~ *.ends-with(exts);
        }
    }
}

my \remarks = do {
    constant Kind = PDS::Remark::Kind;
    my \kinds = Kind.enums.keys.map({ .fc => Kind::{$_} }).Map;
    $remarks.split(",")».&{kinds{.fc}}.grep(*.defined).Set
};

# more preliminaries

sub note-warning(Str:D \msg --> Bool:D)
{
    constant header = "WARNING";
    constant styles = "bold red";
    my \lines = msg.split("\n");

    if lines.elems <= 1 {
        my \styled-header       = style-with-colours("‣ {header}", styles);

        note "{styled-header} {lines[0]}"
    } else {
        my \styled-header       = style-with-colours("┌ {header}", styles);
        my \styled-continuation = style-with-colours("│ ", styles);
        my \styled-closer       = style-with-colours("└ ", styles);

        note qq:to«END».chomp
        {styled-header} {lines[0]}{lines[1..^(*-1)].map("\n" ~ styled-continuation ~ *).join}
        {styled-closer}{lines[(*-1)..*]}
        END
    }
}

package status { enum status «success expected-failure failure unexpected-success»; }

class ProcessResult {
    has $.path;
    has $.result;
    has $.remarks;

    method status(--> status::status:D) {
        given is-whitelisted($.path, whitelist), $.result {
            when !*, Failure.none { status::success }
            when ?*, Failure      { status::expected-failure }
            when !*, Failure      { status::failure }
            when ?*, Failure.none { status::unexpected-success }
        }
    }
}

sub process-file(IO:D \file --> ProcessResult:D)
{
    my \dir = file.SPEC.catdir(path-components(file)[^(*-1)]).IO;
    my \candidates = victoria2-grammars.grep({ path-matches(dir, .where.List) });
    if candidates.elems > 1 {
        note-warning qq:to«END».chomp
        File ‘{file.path}’ is ambiguous because its path matches the following:
        • {candidates.map({ "‘{.where.join("/")}’ for {.descr}" }).join("\n• ")}
        It is being treated as if it were part of the {candidates[0].descr}.
        Possible fix: point $*PROGRAM-NAME to a higher base path to help disambiguate.
        END
    }
    my \grammar = candidates ?? candidates[0] !! victoria2-fallback;

    my \parsed = PDS::parse(grammar, file);

    # condense entire match to concrete result in case of success
    # this avoids carrying around file contents inside (sometimes huge) ast pieces
    my $result = (parsed andthen .Bool orelse parsed);
    my $remarks = (parsed andthen .made<REMARKS>.unique).List;
    ProcessResult.new(path => file, :$result, :$remarks)
}

# get started

if @files.elems == 0 {
    if @requests {
        print qq:to«END»;
        $*PROGRAM-NAME found no files to process.
        END
    } else {
        print qq:to«END»;
        $*PROGRAM-NAME had no files to process because no path was specified. If this was not what you intended, see usage with `$*PROGRAM-NAME --help`.
        END
    }
    return
} else {
    say "$*PROGRAM-NAME is processing {@files.elems} {@files.elems == 1 ?? "file" !! "files"}...";
    $*OUT.flush;
}

# do the work

my \heartbeats = do with $heartbeat { Supply.interval($_, $_).map({ now.DateTime.local.hh-mm-ss }) };
my \processing = start
    @files
    .race(degree => $jobs, :1batch)
    .map(&process-file)
    .classify(*.status);

my \start = now;
my \results = await supply {
    with heartbeats {
        whenever heartbeats {
            say " ...processing ($_)...";
            $*OUT.flush
        }
    }

    whenever processing {
        .emit;
        done
    }
}
my \stop = now;
my \duration = stop - start;

# report results

my \count-width = [max] results.values.map({ .elems.chars });

my \number = {
    file => { $_ <= 1 ?? "file " !! "files" },
    it   => { $_ <= 1 ?? "it"    !! "they" },
    was  => { $_ <= 1 ?? "was"   !! "were" },
};

sub style-outcome(\items, &descr, \styles, Bool :$explain)
{
    if items {
        my \count = items.elems;
        my \fancied = style-with-colours("{count.fmt("%{count-width}d")} {number<file>(count)}", styles);

        my \explanations = do if $explain {
            ":\n\n" ~ do if items».result.any ~~ Failure {
                items».&{ given .result { .exception ~ .backtrace.nice.chomp } }.join("\n\n").indent(8)
            } else {
                items».path.join("\n").indent(8)
            }
        } else {
            "."
        }

        my \spacing = $explain ?? "\n\n    " !! " ";

        my \candidates = items.grep({ ([(+)] .remarks.map(*.kinds)) ∩ remarks }).List;
        my \remark-report = do if candidates.map(*.remarks).flat {
            sub format-remarks(\remarks --> Str:D) {
                my \line-width = [max] remarks.cache».&{.line.chars};

                remarks.map({
                    my \plain-prefix = "line {.line.fmt("%{line-width}d")}: ";
                    my \line-prefix = "line {style-with-colours(.line.fmt("%{line-width}d"), "blue")}: ";
                    line-prefix ~ .message.indent(plain-prefix.chars).trim-leading.chomp
                }).join("\n").indent(4)
            }

            qq:to«END»;
            {number<it>(count).tc} {number<was>(count)} accompanied by the following remarks:

            {candidates».&{ "in ‘{style-with-colours(.path.path, "cyan")}’:\n{format-remarks(.remarks)}" }.join("\n\n").indent(4)}
            END
        } else {
            ""
        }

        qq:to«END»;
          • {fancied} {descr(count)}{explanations}{spacing}{remark-report}
        END
    } else {
        Nil
    }
}

put qq:to«END»;
Processed all {@files.elems <= 1 ?? "file" !! "files"} in {duration.fmt("%.2fs")}:
END

.print with style-outcome(results{status::success}, { "{number<was>($_)} successfully accepted" }, "green");
.print with style-outcome(results{status::expected-failure}, { "from the whitelist {number<was>($_)} rejected as expected" }, "green");
.print with style-outcome(results{status::failure}, { "{number<was>($_)} unexpectedly rejected" }, "red", :explain);
.print with style-outcome(results{status::unexpected-success}, { "from the whitelist {number<was>($_)} accepted when {number<it>($_)} should have been rejected" }, "red", :explain);

exit(1) if results{status::failure}.any | results{status::unexpected-success}.any
